<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Resume Ranker â€” Synonyms & Title Match</title>

<!-- Libraries -->
<script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://unpkg.com/mammoth@1.6.0/dist/mammoth.browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script>if(window.pdfjsLib) pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
:root{
  --bg:#eef6ff;
  --card:#ffffff;
  --text:#0f1724;
  --muted:#5b6b87;
  --primary:#0066ff;
  --accent:#00c3ff;
  --good:#14824b; --warn:#d98b0f; --bad:#c0392b;
}
*{box-sizing:border-box;margin:0;padding:0;font-family:Poppins,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;}
body{background:var(--bg);color:var(--text);padding:20px;display:flex;justify-content:center;}
.app{max-width:1140px;width:100%;}

/* HEADER */
.header{
  position:relative;border-radius:20px;padding:36px 32px;margin-bottom:26px;overflow:hidden;
  background:linear-gradient(135deg,#0575e6 0%, #00c6ff 100%);
  color:white;box-shadow:0 10px 30px rgba(2,20,50,0.12);
}
.header-inner{display:flex;align-items:center;justify-content:space-between;gap:16px;flex-wrap:wrap;}
.brand{display:flex;align-items:center;gap:14px;}
.logo{width:72px;height:72px;border-radius:12px;background:linear-gradient(135deg,#004ecc,#00d0ff);display:flex;align-items:center;justify-content:center;color:white;font-weight:800;font-size:24px;box-shadow:0 6px 18px rgba(0,0,0,0.12);}
h1{font-size:28px;margin:0;letter-spacing:0.6px;font-weight:800;line-height:1;}
.tagline{margin-top:6px;color:rgba(255,255,255,0.92);font-size:15px;max-width:680px;}
.header::before{
  content:"";position:absolute;inset:0;pointer-events:none;
  background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.08), rgba(255,255,255,0.03));
  mix-blend-mode:overlay;
  animation:shimmer 8s linear infinite;
}
@keyframes shimmer{0%{transform:translateX(-100%);}100%{transform:translateX(100%);}}

/* floating icons */
.icon-float{position:absolute;width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:20px;background:rgba(255,255,255,0.09);border:1px solid rgba(255,255,255,0.12);color:white;transition:transform .35s;}
.icon-float:hover{transform:translateY(-6px) scale(1.06);}
.icon1{top:12px;left:12px;}
.icon2{top:12px;right:12px;}
.icon3{bottom:12px;left:12px;}
.icon4{bottom:12px;right:12px;}

/* MAIN PANEL */
.panel{background:var(--card);padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(8,20,40,0.06);}
label{display:block;font-weight:700;margin-bottom:8px;color:var(--muted);}
textarea,input[type="file"],input[type="text"]{width:100%;padding:12px;border-radius:10px;border:1px solid rgba(12,34,63,0.08);font-size:14px;background:white;resize:vertical;}
textarea{min-height:120px;}
.controls{display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap;}
.btn{background:linear-gradient(135deg,var(--primary),var(--accent));color:white;border:none;padding:12px 16px;border-radius:10px;cursor:pointer;font-weight:700;}
.btn:hover{transform:translateY(-3px);box-shadow:0 8px 20px rgba(0,120,255,0.12);}

/* progress */
.progress-container{margin-top:14px;display:none;}
.progress-wrap{height:14px;background:#eef6ff;border-radius:10px;overflow:hidden;}
.progress-bar{height:100%;width:0;background:linear-gradient(90deg,var(--primary),var(--accent));transition:width 300ms;}
.progress-text{font-size:13px;color:var(--muted);margin-top:8px;text-align:center;}

/* results */
.results{margin-top:18px;}
.result-card{display:flex;justify-content:space-between;align-items:flex-start;padding:12px;border-radius:10px;background:var(--card);border-left:6px solid var(--primary);box-shadow:0 6px 18px rgba(12,34,63,0.04);margin-bottom:12px;}
.badge{padding:6px 10px;border-radius:999px;color:white;font-weight:800;}
.badge.good{background:var(--good);} .badge.warn{background:var(--warn);} .badge.bad{background:var(--bad);}
.breakdown{font-size:13px;color:var(--muted);margin-top:6px;}
.snippet{margin-top:8px;background:rgba(0,0,0,0.03);padding:8px;border-radius:8px;font-size:13px;color:#243142;}

/* responsive */
@media (max-width:760px){
  h1{font-size:20px;}
  .header-inner{flex-direction:column;align-items:flex-start;gap:12px;}
  .icon1,.icon2,.icon3,.icon4{width:38px;height:38px;font-size:18px;}
  .result-card{flex-direction:column;align-items:flex-start;}
}
</style>
</head>
<body>
<div class="app">
  <header class="header" role="banner" aria-label="AI Resume Ranker header">
    <div class="icon-float icon1" aria-hidden="true">ðŸ¤–</div>
    <div class="icon-float icon2" aria-hidden="true">ðŸ’¼</div>
    <div class="icon-float icon3" aria-hidden="true">âœ¨</div>
    <div class="icon-float icon4" aria-hidden="true">ðŸ“Š</div>

    <div class="header-inner">
      <div class="brand" style="min-width:0;">
        <div class="logo" aria-hidden="true">AI</div>
        <div style="min-width:0;">
          <h1>AI Resume Ranker</h1>
          <div class="tagline">Match job title, skills, and experience â€” with synonyms and smarter scoring.</div>
        </div>
      </div>

      <div style="text-align:right;">
        <div style="font-weight:700">Smarter Screening</div>
        <div style="font-size:13px;margin-top:6px;color:rgba(255,255,255,0.92)">Upload resumes â€¢ Analyze â€¢ Export</div>
      </div>
    </div>
  </header>

  <div class="panel" role="main" aria-label="Resume screener">
    <label for="jobDesc">Job Description</label>
    <textarea id="jobDesc" placeholder="Paste job description here (adding a 'Title:' line and a 'Skills:' line helps)."></textarea>

    <div style="margin-top:12px;">
      <label for="resumeUpload">Upload Resumes (PDF, DOCX, TXT)</label>
      <input id="resumeUpload" type="file" multiple accept=".pdf,.docx,.txt">
    </div>

    <div class="controls">
      <button id="analyzeBtn" class="btn">ðŸš€ Analyze & Rank</button>
      <div style="flex:1">
        <div class="progress-container" id="progressContainer">
          <div class="progress-wrap"><div id="progressBar" class="progress-bar"></div></div>
          <div id="progressText" class="progress-text">Preparing...</div>
        </div>
      </div>
    </div>
  </div>

  <div id="results" class="results" aria-live="polite"></div>

  <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px;">
    <button id="exportCSV" class="btn" style="display:none">ðŸ“„ Export CSV</button>
    <button id="exportPDF" class="btn" style="display:none">ðŸ§¾ Export PDF</button>
  </div>
</div>

<script>
/* --------------------------
   DOM refs (must be declared early)
   -------------------------- */
const jobDescEl = document.getElementById('jobDesc');
const resumeUpload = document.getElementById('resumeUpload');
const analyzeBtn = document.getElementById('analyzeBtn');
const resultsDiv = document.getElementById('results');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const exportCSV = document.getElementById('exportCSV');
const exportPDF = document.getElementById('exportPDF');

let lastResults = [];

/* --------------------------
   Utilities & extraction
   -------------------------- */
async function extractPDFText(file){
  try{
    const arr = await file.arrayBuffer();
    if(!window.pdfjsLib) return '';
    const pdf = await pdfjsLib.getDocument({data:arr}).promise;
    let text = '';
    for(let i=1;i<=pdf.numPages;i++){
      const page = await pdf.getPage(i);
      const content = await page.getTextContent();
      text += content.items.map(it => it.str).join(' ') + ' ';
    }
    return text;
  }catch(e){ console.warn('PDF extract failed', e); return ''; }
}
async function extractDOCXText(file){
  try{
    const arr = await file.arrayBuffer();
    if(window.mammoth){
      const { value } = await mammoth.extractRawText({ arrayBuffer: arr });
      if(value && value.trim()) return value;
    }
  }catch(e){ console.warn('mammoth failed', e); }
  try{
    const zip = await JSZip.loadAsync(file);
    const xml = await zip.file('word/document.xml').async('string');
    return xml.replace(/<[^>]+>/g,' ');
  }catch(e){ console.warn('jszip fallback failed', e); }
  try{ return await file.text(); }catch(e){ return ''; }
}
async function extractTXTText(file){ return await file.text(); }
async function extractText(file){
  const n = file.name.toLowerCase();
  if(n.endsWith('.pdf')) return await extractPDFText(file);
  if(n.endsWith('.docx')) return await extractDOCXText(file);
  if(n.endsWith('.txt')) return await extractTXTText(file);
  // fallback: try plain text
  try{ return await file.text(); }catch(e){ return ''; }
}
function normalize(s){
  if(!s) return '';
  return s.toLowerCase().replace(/[^a-z0-9+\-#\. ]/g,' ').replace(/\s+/g,' ').trim();
}
function tokenize(s){ if(!s) return []; return normalize(s).split(/\s+/).filter(Boolean); }
function unique(arr){ return [...new Set(arr)]; }
function escapeHtml(t){ return (t||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

/* --------------------------
   Synonym maps
   -------------------------- */
const skillSynonyms = {
  "react": ["react.js","reactjs","reactjs.org"],
  "node": ["node.js","nodejs"],
  "js": ["javascript"],
  "ts": ["typescript"],
  "aws": ["amazon web services","amazonaws"],
  "gcp": ["google cloud","google cloud platform"],
  "sql": ["postgres","postgresql","mysql"],
  "docker": ["container","containers"],
  "kubernetes": ["k8s","kubernetes.io"],
  "html": ["html5"],
  "css": ["css3","scss"]
};

const titleSynonyms = {
  "engineer": ["developer","software engineer","software developer","sde","sde2","sde1"],
  "data scientist": ["data analyst","ml engineer","machine learning engineer","ml scientist"],
  "product manager": ["pm","product owner"],
  "qa": ["test engineer","quality assurance","qa engineer"]
};

function buildReverseMap(map){
  const rev = {};
  for(const key of Object.keys(map)){
    const variants = [key, ...map[key]];
    variants.forEach(v=>{
      const norm = normalize(v);
      rev[norm] = normalize(key);
    });
  }
  return rev;
}
const skillRev = buildReverseMap(skillSynonyms);
const titleRev = buildReverseMap(titleSynonyms);

function canonicalSkillToken(token){
  const n = normalize(token);
  if(skillRev[n]) return skillRev[n];
  if(n.endsWith('js')) return 'js';
  return n;
}
function canonicalTitleToken(token){
  const n = normalize(token);
  if(titleRev[n]) return titleRev[n];
  return n;
}

/* --------------------------
   Extract skills & title from JD
   -------------------------- */
function extractSkillsFromJD(jdText){
  if(!jdText) return [];
  const lines = jdText.split(/\r?\n/);
  for(const ln of lines){
    const low = ln.toLowerCase().trim();
    if(low.startsWith('skills:') || low.startsWith('skill:') || low.startsWith('requirements:')){
      const right = ln.split(':').slice(1).join(':').trim();
      const parts = right.split(/[,;|\/Â·â€¢]/).map(p=>p.trim()).filter(Boolean);
      return unique(parts.map(p=>canonicalSkillToken(p)));
    }
  }
  // fallback: pick top meaningful tokens from JD
  const tokens = tokenize(jdText).filter(t => t.length>2);
  const stop = new Set(['the','and','with','from','that','this','will','your','you','are','for','using','use','years','experience','skill','required','requirements','candidate','responsibilities','responsibility','work','team','ability','strong']);
  const freq = {};
  tokens.forEach(t=>{ if(!stop.has(t)) freq[t] = (freq[t]||0)+1; });
  const sorted = Object.keys(freq).sort((a,b)=>freq[b]-freq[a]).slice(0,18);
  return unique(sorted.map(tok=>canonicalSkillToken(tok)));
}

function extractTitleFromJD(jdText){
  if(!jdText) return '';
  const lines = jdText.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  // search for explicit "Title:" line
  for(const ln of lines){
    const low = ln.toLowerCase();
    if(low.startsWith('title:') || low.startsWith('job title:')){
      return canonicalTitleToken(ln.split(':').slice(1).join(':').trim());
    }
  }
  // heuristic: first line if it's short (<=6 words)
  if(lines.length){
    const first = lines[0];
    if(first.split(/\s+/).length <= 6) return canonicalTitleToken(first);
  }
  return '';
}

/* --------------------------
   Skill matching (fuzzy)
   -------------------------- */
function countSkillMatches(jobSkills, resumeText){
  if(!jobSkills || !jobSkills.length) return 0;
  const rnorm = normalize(resumeText);
  const found = new Set();
  for(const sk of jobSkills){
    if(!sk) continue;
    const skCanon = canonicalSkillToken(sk);
    // regex word boundary check against the normalized resume text words
    const words = rnorm.split(/\s+/);
    if(words.includes(skCanon)) { found.add(skCanon); continue; }
    if(rnorm.includes(skCanon)) { found.add(skCanon); continue; }
    // check synonyms
    for(const synKey of Object.keys(skillSynonyms)){
      const syns = [synKey, ...skillSynonyms[synKey]];
      if(syns.map(s=>normalize(s)).includes(skCanon)){
        if(syns.some(v => rnorm.includes(normalize(v)))) { found.add(skCanon); break; }
      }
    }
  }
  return found.size;
}

/* --------------------------
   Title matching (fuzzy)
   -------------------------- */
function titleMatchScore(jobTitle, resumeText){
  if(!jobTitle) return 0;
  const jcanon = canonicalTitleToken(jobTitle);
  const rnorm = normalize(resumeText);
  if(!rnorm) return 0;
  if(rnorm.includes(jcanon)) return 1;
  for(const key of Object.keys(titleSynonyms)){
    const variants = [key, ...titleSynonyms[key]];
    if(variants.map(v => normalize(v)).includes(jcanon)){
      if(variants.some(v => rnorm.includes(normalize(v)))) return 1;
    }
  }
  const jtoks = tokenize(jobTitle).filter(t=>t.length>2);
  const rtoks = new Set(tokenize(resumeText));
  const matches = jtoks.filter(t => rtoks.has(t) || rnorm.includes(t)).length;
  if(jtoks.length===0) return 0;
  return Math.min(1, matches / jtoks.length);
}

/* --------------------------
   Experience extraction & scoring
   -------------------------- */
function extractYears(text){
  if(!text) return null;
  const matches = [...text.matchAll(/(\d{1,2})\s*\+?\s*(?:years|yrs|year|yr)\b/ig)];
  const nums = matches.map(m=>parseInt(m[1],10)).filter(n=>!isNaN(n));
  if(nums.length) return Math.max(...nums);
  const compact = [...text.matchAll(/(\d{1,2})\+/g)].map(m=>parseInt(m[1],10)).filter(n=>!isNaN(n));
  if(compact.length) return Math.max(...compact);
  return null;
}
function experienceScore(jobYears, resumeYears){
  if(jobYears==null && resumeYears==null) return 0.5;
  if(jobYears==null && resumeYears!=null) return Math.min(1, 0.6 + Math.min(10,resumeYears)*0.04);
  if(jobYears!=null && resumeYears==null) return Math.max(0, 1 - (jobYears*0.18));
  const diff = resumeYears - jobYears;
  if(diff >= 0) return 1;
  const score = 1 - (Math.abs(diff)/Math.max(1, jobYears));
  return Math.max(0, Math.min(1, score));
}

/* --------------------------
   Semantic similarity (sentence-level Jaccard)
   -------------------------- */
function semanticScore(jobText, resumeText){
  if(!jobText || !resumeText) return 0;
  const jobP = jobText.split(/[.!?]/).map(s=>s.trim()).filter(Boolean);
  const resP = resumeText.split(/[.!?]/).map(s=>s.trim()).filter(Boolean);
  if(!jobP.length || !resP.length) return 0;
  let total = 0;
  for(const jp of jobP){
    let best = 0;
    const ja = new Set(tokenize(jp));
    for(const rp of resP){
      const ra = new Set(tokenize(rp));
      const inter = [...ja].filter(x=>ra.has(x)).length;
      const union = new Set([...ja,...ra]).size || 1;
      const sim = inter/union;
      if(sim>best) best = sim;
    }
    total += best;
  }
  return Math.min(1, total / jobP.length);
}

/* --------------------------
   Combine signals (weights)
   -------------------------- */
const WEIGHTS = { skills:0.50, title:0.20, experience:0.20, semantic:0.10 };

function computeFinal(jobSkills, resumeText, jobTitle, jobYears, resumeYears, jobText){
  const skillMatches = countSkillMatches(jobSkills, resumeText);
  const skillDenom = Math.max(1, jobSkills.length);
  const skillsRatio = Math.min(1, skillMatches / skillDenom); // 0..1
  const titleScore = titleMatchScore(jobTitle, resumeText); // 0..1
  const expScore = experienceScore(jobYears, resumeYears); // 0..1
  const semScore = semanticScore(jobText, resumeText); // 0..1

  const raw = (WEIGHTS.skills * skillsRatio) + (WEIGHTS.title * titleScore) + (WEIGHTS.experience * expScore) + (WEIGHTS.semantic * semScore);
  const pct = Math.round(Math.max(0, Math.min(1, raw)) * 100);
  return {
    final:pct,
    skillsPct: Math.round(skillsRatio*100),
    titlePct: Math.round(titleScore*100),
    expPct: Math.round(expScore*100),
    semPct: Math.round(semScore*100),
    matchedSkills: skillMatches,
    totalJobSkills: jobSkills.length
  };
}

/* --------------------------
   UI wiring & main flow
   -------------------------- */
function setProgress(p, msg=''){
  // show while in progress (0..100). show at 0 only if msg provided.
  if((p>0 && p<100) || (p===0 && msg)) progressContainer.style.display = 'block';
  else progressContainer.style.display = (p>=100 ? 'none' : progressContainer.style.display);
  progressBar.style.width = Math.max(0, Math.min(100, p)) + '%';
  progressText.textContent = msg ? `${msg} (${Math.round(p)}%)` : '';
}

function parseJob(jobText){
  const skills = extractSkillsFromJD(jobText);
  const title = extractTitleFromJD(jobText);
  const years = extractYears(jobText);
  return { skills, title, years };
}

analyzeBtn.addEventListener('click', async ()=>{
  resultsDiv.innerHTML = '';
  lastResults = [];
  exportCSV.style.display = exportPDF.style.display = 'none';
  const jobText = (jobDescEl.value || '').trim();
  if(!jobText){ alert('Please paste the job description (include Title: and Skills: lines if possible).'); return; }
  const files = Array.from(resumeUpload.files || []);
  if(files.length === 0){ alert('Please upload one or more resumes.'); return; }

  setProgress(3,'Parsing job description');
  const parsed = parseJob(jobText);
  const jobSkills = parsed.skills;
  const jobTitle = parsed.title;
  const jobYears = parsed.years;

  // Info card
  const info = document.createElement('div');
  info.className = 'panel';
  info.style.marginBottom = '12px';
  info.innerHTML = `<div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
    <div style="font-weight:700">Job Title:</div><div style="color:var(--muted)">${escapeHtml(jobTitle || '(none detected)')}</div>
    <div style="font-weight:700;margin-left:12px">Skills:</div><div style="color:var(--muted)">${jobSkills.length? jobSkills.join(', '):'(none detected)'}</div>
    <div style="margin-left:auto;color:var(--muted)">Years: ${jobYears!=null?jobYears:'(not specified)'}</div>
  </div>`;
  resultsDiv.appendChild(info);

  setProgress(8,'Reading resumes');

  for(let i=0;i<files.length;i++){
    const f = files[i];
    setProgress(8 + Math.round((i/files.length)*70), 'Reading ' + f.name);
    let txt = '';
    try{ txt = await extractText(f); }catch(e){ txt = ''; }
    if(!txt){
      try{ txt = await f.text(); }catch(e){ txt = ''; }
    }

    const resumeYears = extractYears(txt);
    const res = computeFinal(jobSkills, txt, jobTitle, jobYears, resumeYears, jobText);

    lastResults.push({
      name: f.name,
      final: res.final,
      skillsPct: res.skillsPct,
      titlePct: res.titlePct,
      expPct: res.expPct,
      semPct: res.semPct,
      matchedSkills: res.matchedSkills,
      totalJobSkills: res.totalJobSkills,
      resumeYears,
      jobYears,
      snippet: (txt||'').slice(0,420).replace(/\s+/g,' ').trim()
    });

    // small breathing time for UI
    await new Promise(r=>setTimeout(r,80));
  }

  // sort & render
  lastResults.sort((a,b)=>b.final - a.final);
  setProgress(96,'Rendering results');

  for(let i=0;i<lastResults.length;i++){
    const r = lastResults[i];
    const card = document.createElement('div');
    card.className = 'result-card';
    const badgeClass = r.final >= 80 ? 'badge good' : (r.final >=50 ? 'badge warn' : 'badge bad');
    const badgeHtml = `<div class="${badgeClass}">${r.final} / 100</div>`;

    card.innerHTML = `
      <div style="flex:1">
        <div style="font-weight:800">${i+1}. ${escapeHtml(r.name)}</div>
        <div class="breakdown">
          Skills: <strong>${r.skillsPct}%</strong> (${r.matchedSkills}/${r.totalJobSkills}) Â· Title: <strong>${r.titlePct}%</strong> Â· Experience: <strong>${r.expPct}%</strong> (${r.resumeYears!=null?r.resumeYears+' yrs':'n/a'})
        </div>
        <div class="snippet">${escapeHtml(r.snippet || '(no text extracted)')}</div>
      </div>
      <div style="display:flex;flex-direction:column;align-items:flex-end;gap:8px">
        ${badgeHtml}
        <div style="font-size:13px;color:var(--muted)">Confidence</div>
      </div>
    `;
    resultsDiv.appendChild(card);
  }

  setProgress(100,'Done');
  exportCSV.style.display = exportPDF.style.display = 'inline-block';
});

/* --------------------------
   Export handlers
   -------------------------- */
exportCSV.addEventListener('click', ()=>{
  if(!lastResults.length) return alert('No results to export.');
  const header = ['Rank','Filename','Score','Skills%','Title%','Experience%','Context%','ResumeYears','JobYears'];
  const rows = lastResults.map((r,idx)=>[idx+1, r.name, r.final, r.skillsPct, r.titlePct, r.expPct, r.semPct, r.resumeYears||'', r.jobYears||'']);
  const csv = [header.join(','), ...rows.map(r => r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(','))].join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'resume_ranking.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

exportPDF.addEventListener('click', ()=>{
  if(!lastResults.length) return alert('No results to export.');
  const { jsPDF } = window.jspdf || {};
  if(!jsPDF){ alert('PDF export library not loaded.'); return; }
  const doc = new jsPDF({unit:'pt', format:'a4'});
  const margin = 40; let y = 50;
  doc.setFontSize(16); doc.text('AI Resume Ranker â€” Results', margin, y); y+=22;
  doc.setFontSize(10); doc.text('Generated: ' + new Date().toLocaleString(), margin, y); y+=18;
  lastResults.forEach((r, idx)=>{
    if(y > 760){ doc.addPage(); y = 50; }
    doc.setFontSize(12); doc.text(`${idx+1}. ${r.name} â€” ${r.final} / 100`, margin, y); y += 14;
    doc.setFontSize(10);
    doc.text(`Skills: ${r.skillsPct}% (${r.matchedSkills}/${r.totalJobSkills})  Â·  Title: ${r.titlePct}%  Â·  Experience: ${r.expPct}% (${r.resumeYears!=null?r.resumeYears+' yrs':'n/a'})  Â·  Context: ${r.semPct}%`, margin, y);
    y += 12;
    const snippet = (r.snippet || '').replace(/\s+/g,' ').trim();
    const lines = doc.splitTextToSize(snippet, 520);
    doc.text(lines, margin, y);
    y += lines.length*11 + 12;
  });
  doc.save('resume_ranking.pdf');
});

/* --------------------------
   Drag & drop convenience
   -------------------------- */
/* Prevent default browser behavior for drag/drop */
['dragenter','dragover'].forEach(e => document.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }, false));
['dragleave','drop'].forEach(e => document.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }, false));

/* Accept dropped files and set input.files via DataTransfer (read-only fix) */
document.addEventListener('drop', ev => {
  const f = ev.dataTransfer.files;
  if(f && f.length){
    try{
      const dt = new DataTransfer();
      for(let i=0;i<f.length;i++) dt.items.add(f[i]);
      resumeUpload.files = dt.files;
      // optionally run analysis automatically (commented out)
      // analyzeBtn.click();
    }catch(e){
      console.warn('Drag/drop assign failed', e);
    }
  }
});

/* init */
setProgress(0,'');
</script>
</body>
</html>
